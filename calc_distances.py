# calc_distances.py:
#
#       Generate a GeoJSON FeatureCollection consisting of a set of points generated at a set interval along a given LineString.
#
#       Input: * A GeoJSON file generated by chunkify.js.
#              * The distance between points.
#
#       Output: A GeoJSON FeatureCollection which consists of a set of Points, with Properties "nobo_mi" and "sobo_mi".
#
#       Notes:  
#              * chunkify.js turns a single LineString into a set of shorter LineStrings. The first point in each LineString is the same as the last point in the previous LineString.
#              * turfpy.measurement.along() runs much faster on points that are less than a few hundred miles along the LineString. Operating on a set of short chunks significantly increases performance. 
#

from turfpy import measurement 
import geojson 
import json 
import datetime
from numpy import arange 

def calc_seg(seg_num, seg, interval, trail_length):
    points = []
    seg_len = round(measurement.length(seg, units="mi"), 1)
    print("seg_len: {seg_len} mi.".format(seg_len = seg_len))

    # start at interval b/c chunkify.js creates linestrings where the first point of linestring(n) == the last point of linestring(n1). 
    for dist in arange(interval, seg_len + 0.01, interval):
        dist_rounded = round(dist, 1)
        print(dist_rounded, end=', ')
        point = measurement.along(seg, dist_rounded, "mi")
        point['properties']['nobo_mi'] = round(((seg_num * 10) + dist_rounded), 1)
        point['properties']['sobo_mi'] = round((trail_length - ((seg_num * 10) + dist_rounded)), 1)
        points.append(point)

    return(points)


# Settings.
folder = r'c:\path\to\file' '\\'
# Run chunkify.js on a GeoJSON linestring first to generate a suitable infile.
infile_chunked_trail = r'trail-chunks.geojson'
outfile = r'trail-distances-' + datetime.datetime.now().strftime('%H-%M-%S-%f') + '.geojson'
interval = 0.1

# Load infile.
with open(folder + infile_chunked_trail, 'r') as f:
    chunked_trail = json.load(f)

# Load infile features to feats[], calculate total length. 
trail_length = 0.0
feats = []
for feat in chunked_trail['features']:
    trail_length += measurement.length(feat, units = 'mi')
    feats.append(feat)

trail_length = round(trail_length, 1)

points = []
# Prime the loop by adding the first point. Chunkify.js creates segments where the last point in a linestring is the first point in the next linestring
# so calc_section skips the first point in each linestring and goes from 0.1 to len(seg). 
points.append(geojson.Feature(geometry = geojson.Point(feats[0]['geometry']['coordinates'][0]), properties = {"nobo_mi": 0.0, "sobo_mi": trail_length}))

# Main loop.
for i, f in enumerate(feats):
    print('\n\nsegment {segment:03d}'.format(segment = i))
    
    points.extend(calc_seg(i, f, interval, trail_length))

# Save output.
fc = geojson.FeatureCollection(points)
with open(folder + outfile, "w") as f:
    json.dump(fc, f)
